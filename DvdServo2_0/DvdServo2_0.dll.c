/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

jint __cdecl regForAsyncEventsCallback(int key, JNIEnv *env);
int __cdecl commonFunctionCallback(int a1, int key, unsigned __int16 opId, int res);
jint __cdecl getTaggedInfoCallback(int key, unsigned __int16 opId, int res);
int __cdecl getStatusQuickCallback(int a1, int key, unsigned __int16 opId, int res);
int __cdecl rotateToSlotCallback(int a1, int key, unsigned __int16 opId, int res);
int __cdecl ejectCaseFromSlotCallback(int a1, int key, unsigned __int16 opId, int res);
int __stdcall Java_net_dvdplay_aem_DPEC_RegForAsyncEvents(JNIEnv *env, jclass clz, int cbRegEvtKey);
int __stdcall Java_net_dvdplay_aem_DPEC_StartOperation(JNIEnv *env, jclass clz, jint lKey, jint aLocation, jint tagType, jint var3);
void __stdcall Java_net_dvdplay_aem_DPEC_GetLibraryVersion(JNIEnv *env, jclass clz);
// int sprintf(char *const Buffer, const char *const Format, ...);

//-------------------------------------------------------------------------
// Data declarations

// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
CHAR aDpecRegForAsyncEvnets[] = "DPEC_RegForAsyncEvents"; // idb
CHAR aDpecStartopera[] = "DPEC_StartOperation"; // idb
int g_quickStat = 0; // weak
int g_slotStat = 0; // weak
int gEjectCaseFromSlot = 0; // weak
int g_getStatusQuick = 0; // weak
int gExceptionClass = 0; // weak
char g_strStatus[] = { '\0' }; // weak
int gRegForAsyncEvents = 0; // weak
int gRotateToSlot = 0; // weak
int gCommonFunction = 0; // weak
int gDpecClass = 0; // weak
HMODULE dpecHandle = NULL; // idb
JavaVM *javaVm = NULL;


//----- (10001010) --------------------------------------------------------
jint __cdecl regForAsyncEventsCallback(int key, JNIEnv *env)
{
  JNIEnv *event; // esi
  jint result; // eax

  event = env;
  if ( (int)env > 4 )
  {
    (*javaVm)->AttachCurrentThread(javaVm, (void **)&env, 0);
    (*env)->CallStaticVoidMethod(env, (jclass)gDpecClass, (jmethodID)gRegForAsyncEvents, key, event);
    return (*javaVm)->DetachCurrentThread(javaVm);
  }
  return result;
}
// 1000C200: using guessed type int gRegForAsyncEvents;
// 1000C20C: using guessed type int gDpecClass;

//----- (10001060) --------------------------------------------------------
int __cdecl commonFunctionCallback(int a1, int key, unsigned __int16 opId, int res)
{
  int v4; // ecx
  int v6; // [esp+Ch] [ebp-4h] BYREF
  void *retaddr; // [esp+10h] [ebp+0h]

  v6 = v4;
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&v6, 0);
  (*(void (__cdecl **)(void *, int, int, int, _DWORD, int))(*(_DWORD *)retaddr + 564))(
    retaddr,
    gDpecClass,
    gCommonFunction,
    key,
    opId,
    res);
  return ((int (__cdecl *)(JavaVM *))(*javaVm)->DetachCurrentThread)(javaVm);
}
// 10001060: variable 'v4' is possibly undefined
// 1000C208: using guessed type int gCommonFunction;
// 1000C20C: using guessed type int gDpecClass;

//----- (100010C0) --------------------------------------------------------
jint __cdecl getTaggedInfoCallback(int key, unsigned __int16 opId, int res)
{
  int offset; // edi
  int v4; // ebx
  int i; // esi
  JNIEnv *v6; // eax
  int strStatus; // eax
  JNIEnv *v9; // [esp+14h] [ebp-104h] BYREF
  char buffer[256]; // [esp+18h] [ebp-100h] BYREF

  offset = 0;
  v4 = (unsigned __int16)word_1000C1C2;
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&v9, 0);
  if ( !res )
  {
    for ( i = 0; i < v4; ++i )
      offset += sprintf(&buffer[offset], "0x%02X ", (unsigned __int8)g_strStatus[i]);
  }
  v6 = v9;
  buffer[offset] = 0;
  strStatus = (int)(*v6)->NewStringUTF(v6, buffer);
  (*v9)->CallStaticVoidMethod(v9, (jclass)gDpecClass, (jmethodID)g_getTaggedInfo, key, opId, res, strStatus);
  return (*javaVm)->DetachCurrentThread(javaVm);
}
// 1000C1BC: using guessed type int g_getTaggedInfo;
// 1000C1C2: using guessed type __int16 word_1000C1C2;
// 1000C20C: using guessed type int gDpecClass;

//----- (10001180) --------------------------------------------------------
int __cdecl getStatusQuickCallback(int a1, int key, unsigned __int16 opId, int res)
{
  JNIEnv *v4; // ecx
  JNIEnv *v6; // [esp+Ch] [ebp-4h] BYREF
  void *retaddr; // [esp+10h] [ebp+0h]

  v6 = v4;
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&v6, 0);
  (*(void (__cdecl **)(void *, int, int, int, _DWORD, int, int))(*(_DWORD *)retaddr + 564))(
    retaddr,
    gDpecClass,
    g_getStatusQuick,
    key,
    opId,
    res,
    g_quickStat);
  return ((int (__cdecl *)(JavaVM *))(*javaVm)->DetachCurrentThread)(javaVm);
}
// 10001180: variable 'v4' is possibly undefined
// 1000C19C: using guessed type int g_quickStat;
// 1000C1B4: using guessed type int g_getStatusQuick;
// 1000C20C: using guessed type int gDpecClass;

//----- (100011E0) --------------------------------------------------------
int __cdecl rotateToSlotCallback(int a1, int key, unsigned __int16 opId, int res)
{
  JNIEnv *v4; // ecx
  JNIEnv *v6; // [esp+Ch] [ebp-4h] BYREF
  void *retaddr; // [esp+10h] [ebp+0h]

  v6 = v4;
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&v6, 0);
  (*(void (__cdecl **)(void *, int, int, int, _DWORD, int, int))(*(_DWORD *)retaddr + 564))(
    retaddr,
    gDpecClass,
    gRotateToSlot,
    key,
    opId,
    res,
    g_slotStat);
  return ((int (__cdecl *)(JavaVM *))(*javaVm)->DetachCurrentThread)(javaVm);
}
// 100011E0: variable 'v4' is possibly undefined
// 1000C1A0: using guessed type int g_slotStat;
// 1000C204: using guessed type int gRotateToSlot;
// 1000C20C: using guessed type int gDpecClass;

//----- (10001240) --------------------------------------------------------
int __cdecl ejectCaseFromSlotCallback(int a1, int key, unsigned __int16 opId, int res)
{
  JNIEnv *v4; // ecx
  JNIEnv *v6; // [esp+Ch] [ebp-4h] BYREF
  void *retaddr; // [esp+10h] [ebp+0h]

  v6 = v4;
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&v6, 0);
  (*(void (__cdecl **)(void *, int, int, int, _DWORD, int))(*(_DWORD *)retaddr + 564))(
    retaddr,
    gDpecClass,
    gEjectCaseFromSlot,
    key,
    opId,
    res);
  return ((int (__cdecl *)(JavaVM *))(*javaVm)->DetachCurrentThread)(javaVm);
}
// 10001240: variable 'v4' is possibly undefined
// 1000C1A4: using guessed type int gEjectCaseFromSlot;
// 1000C20C: using guessed type int gDpecClass;

//----- (100012A0) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_RegForAsyncEvents(JNIEnv *env, jclass clz, int cbRegEvtKey)
{
  FARPROC DPEC_RegForAsyncEvents; // eax

  DPEC_RegForAsyncEvents = GetProcAddress(dpecHandle, aDpecRegForAsyncEvnets);
  return ((int (__cdecl *)(_DWORD, int))DPEC_RegForAsyncEvents)(regForAsyncEventsCallback, cbRegEvtKey);
}

//----- (100012D0) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_StartOperation(
        JNIEnv *env,
        jclass clz,
        jint lKey,
        jint aLocation,
        jint tagType,
        jint var3)
{
  FARPROC DPEC_StartOperation; // eax
  int result; // eax
  int v8; // ecx
  int returnVal; // [esp+18h] [ebp-84h] BYREF
  char msg[128]; // [esp+1Ch] [ebp-80h] BYREF

  DPEC_StartOperation = GetProcAddress(dpecHandle, aDpecStartopera);
  switch ( aLocation )
  {
    case 6:
      result = ((int (__cdecl *)(int (__cdecl *)(int, int, unsigned __int16, int), jint, int, jint, jint, int *, int *))DPEC_StartOperation)(
                 getStatusQuickCallback,
                 lKey,
                 6,
                 tagType,
                 var3,
                 &g_quickStat,
                 &returnVal);
      break;
    case 12:
      result = ((int (__cdecl *)(int (__cdecl *)(int, int, unsigned __int16, int), jint, int, jint, jint, int *, int *))DPEC_StartOperation)(
                 rotateToSlotCallback,
                 lKey,
                 12,
                 tagType,
                 var3,
                 &g_slotStat,
                 &returnVal);
      break;
    case 4:
      v8 = 64;
      do
      {
        --v8;
        g_strStatus[0] = 0;
      }
      while ( v8 );
      result = ((int (__cdecl *)(jint (__cdecl *)(int, unsigned __int16, int), jint, int, jint, jint, char *, int *))DPEC_StartOperation)(
                 getTaggedInfoCallback,
                 lKey,
                 4,
                 tagType,
                 var3,
                 g_strStatus,
                 &returnVal);
      break;
    case 14:
      result = ((int (__cdecl *)(int (__cdecl *)(int, int, unsigned __int16, int), jint, int, jint, jint, _DWORD, int *))DPEC_StartOperation)(
                 ejectCaseFromSlotCallback,
                 lKey,
                 14,
                 tagType,
                 var3,
                 0,
                 &returnVal);
      break;
    default:
      if ( (unsigned int)aLocation > 25 )
      {
        sprintf(msg, "DPEC Bridge: Unknown OpCode was issued from AEM App! OpCode = %d.", aLocation);
        (*env)->ThrowNew(env, (jclass)gExceptionClass, msg);
        result = returnVal;
      }
      else
      {
        result = ((int (__cdecl *)(int (__cdecl *)(int, int, unsigned __int16, int), jint, jint, jint, jint, _DWORD, int *))DPEC_StartOperation)(
                   commonFunctionCallback,
                   lKey,
                   aLocation,
                   tagType,
                   var3,
                   0,
                   &returnVal);
      }
      break;
  }
  if ( result )
  {
    sprintf(msg, "DPEC Bridge: StartOperation failed! Result = %d.", result);
    (*env)->ThrowNew(env, (jclass)gExceptionClass, msg);
  }
  return (unsigned __int16)returnVal;
}
// 1000C19C: using guessed type int g_quickStat;
// 1000C1A0: using guessed type int g_slotStat;
// 1000C1B8: using guessed type int gExceptionClass;

//----- (10001480) --------------------------------------------------------
jint __stdcall Java_net_dvdplay_aem_DPEC_Connect(JNIEnv *env, jclass a2)
{
  HMODULE LibraryA; // eax
  jint result; // eax
  int (*DPEC_Connect)(void); // edi
  void (*DPEC_Disconnect)(void); // ebp
  void (*DPEC_StartLoggingService)(void); // ebx
  jint connRet; // esi
  bool freeRet; // zf
  void (*DPEC_KillLogging)(void); // [esp+Ch] [ebp+4h]

  (*env)->GetJavaVM(env, &javaVm);
  LibraryA = LoadLibraryA(LibFileName);
  dpecHandle = LibraryA;
  if ( !LibraryA )
    return 2001;
  DPEC_Connect = GetProcAddress(LibraryA, aDpecConnect);
  DPEC_Disconnect = (void (*)(void))GetProcAddress(dpecHandle, aDpecDisconnect);
  DPEC_StartLoggingService = (void (*)(void))GetProcAddress(dpecHandle, aDpecStartloggi);
  DPEC_KillLogging = (void (*)(void))GetProcAddress(dpecHandle, aDpecKillloggin);
  DPEC_StartLoggingService();
  connRet = DPEC_Connect();
  if ( !connRet )
    return connRet;
  DPEC_Disconnect();
  DPEC_KillLogging();
  Sleep(100u);
  freeRet = !FreeLibrary(dpecHandle);
  result = 2002;
  if ( !freeRet )
    return connRet;
  return result;
}

//----- (10001530) --------------------------------------------------------
jint __stdcall Java_net_dvdplay_aem_DPEC_Disconnect(JNIEnv *env, jclass clz)
{
  int (*DPEC_Disconnect)(void); // edi
  void (*DPEC_KillLoggingService)(void); // esi
  jint disconnectRet; // edi
  bool freeRet; // zf
  jint result; // eax

  DPEC_Disconnect = GetProcAddress(dpecHandle, aDpecDisconnect);
  DPEC_KillLoggingService = (void (*)(void))GetProcAddress(dpecHandle, aDpecKillloggin);
  disconnectRet = DPEC_Disconnect();
  DPEC_KillLoggingService();
  freeRet = !FreeLibrary(dpecHandle);
  result = 2002;
  if ( !freeRet )
    return disconnectRet;
  return result;
}

//----- (10001580) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_SetMode(JNIEnv *env, jclass clz, jint a3)
{
  FARPROC DPEC_SetMode; // eax

  DPEC_SetMode = GetProcAddress(dpecHandle, ProcName);
  return ((int (__cdecl *)(jint))DPEC_SetMode)(a3);
}

//----- (100015A0) --------------------------------------------------------
jint __stdcall Java_net_dvdplay_aem_DPEC_GetMode(JNIEnv *env, jclass clz)
{
  int (*DPEC_GetMode)(void); // eax

  DPEC_GetMode = GetProcAddress(dpecHandle, aDpecGetmode);
  return DPEC_GetMode();
}

//----- (100015C0) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_GetOpState(JNIEnv *env, jclass clz, int a3)
{
  FARPROC DPEC_GetOpState; // eax
  int ret; // eax
  int state; // [esp+Ch] [ebp-84h] BYREF
  char Buffer[128]; // [esp+10h] [ebp-80h] BYREF

  DPEC_GetOpState = GetProcAddress(dpecHandle, aDpecGetopstate);
  ret = ((int (__cdecl *)(int, int *))DPEC_GetOpState)(a3, &state);
  if ( ret )
  {
    sprintf(Buffer, "JNI: GetOpState failed! Result = %d.", ret);
    (*env)->ThrowNew(env, (jclass)gExceptionClass, Buffer);
  }
  return state;
}
// 1000C1B8: using guessed type int dword_1000C1B8;

//----- (10001630) --------------------------------------------------------
jint __stdcall Java_net_dvdplay_aem_DPEC_AbortOperation(JNIEnv *env, jclass clz, jint a3)
{
  FARPROC DPEC_AbortOperation; // eax

  DPEC_AbortOperation = GetProcAddress(dpecHandle, aDpecAbortopera);
  return ((int (__cdecl *)(jint))DPEC_AbortOperation)(a3);
}

//----- (10001650) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_StartAppWatchdog(JNIEnv *env, jclass clz)
{
  int (*DPEC_StartAppWatchdog)(void); // eax

  DPEC_StartAppWatchdog = GetProcAddress(dpecHandle, aDpecStartappwa);
  return DPEC_StartAppWatchdog();
}

//----- (10001670) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_StrokeAppWatchdog(JNIEnv *env, jclass clz)
{
  int (*DPEC_StrokeAppWatchdog)(void); // eax

  DPEC_StrokeAppWatchdog = GetProcAddress(dpecHandle, aDpecStrokeappw);
  return DPEC_StrokeAppWatchdog();
}

//----- (10001690) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_KillAppWatchdog(JNIEnv *env, jclass clz)
{
  int (*DPEC_KillAppWatchdog)(void); // eax

  DPEC_KillAppWatchdog = GetProcAddress(dpecHandle, aDpecKillappwat);
  return DPEC_KillAppWatchdog();
}

//----- (100016B0) --------------------------------------------------------
void __stdcall Java_net_dvdplay_aem_DPEC_GetLibraryVersion(JNIEnv *env, jclass clz)
{
  FARPROC DPEC_GetLibraryVersion; // eax
  struct _jobject *obj; // edi
  struct _jobject *str; // ebx
  JNIEnv *jniInterface; // [esp+4Ch] [ebp-60h] BYREF
  int v6; // [esp+50h] [ebp-5Ch] BYREF
  int v7; // [esp+54h] [ebp-58h] BYREF
  int v8; // [esp+58h] [ebp-54h] BYREF
  _BYTE v9[80]; // [esp+5Ch] [ebp-50h] BYREF

  DPEC_GetLibraryVersion = GetProcAddress(dpecHandle, aDpecGetlibrary);
  ((void (__cdecl *)(int *, int *, int *, _BYTE *))DPEC_GetLibraryVersion)(&v6, &v7, &v8, v9);
  (*javaVm)->AttachCurrentThread(javaVm, (void **)&jniInterface, 0);
  (*jniInterface)->SetStaticByteField(jniInterface, (jclass)gDpecClass, (jfieldID)gVersionMajor, v6);
  (*jniInterface)->SetStaticByteField(jniInterface, (jclass)gDpecClass, (jfieldID)gVersionMinor, v7);
  (*jniInterface)->SetStaticShortField(jniInterface, (jclass)gDpecClass, (jfieldID)gVersionBuild, v8);
  obj = (*jniInterface)->AllocObject(jniInterface, gDpecClass);
  str = (*jniInterface)->NewStringUTF(jniInterface, v9);
  (*jniInterface)->SetObjectField(jniInterface, obj, (jfieldID)gVersionString, str);
  (*javaVm)->DetachCurrentThread(javaVm);
  (*env)->DeleteLocalRef(env, str);
  (*env)->DeleteLocalRef(env, obj);
}
// 1000C198: using guessed type int gVersionBuild;
// 1000C1A8: using guessed type int gVersionString;
// 1000C1AC: using guessed type int gVersionMajor;
// 1000C1B0: using guessed type int gVersionMinor;
// 1000C20C: using guessed type int gDpecClass;

//----- (100017C0) --------------------------------------------------------
void __stdcall Java_net_dvdplay_aem_DPEC_AddLineToLog(JNIEnv *env, jclass clz, jstring str)
{
  const char *chars; // edi
  FARPROC DPEC_AddLineToLog; // eax

  chars = (*env)->GetStringUTFChars(env, str, 0);
  DPEC_AddLineToLog = GetProcAddress(dpecHandle, aDpecAddlinetol);
  ((void (__cdecl *)(const char *))DPEC_AddLineToLog)(chars);
  (*env)->ReleaseStringUTFChars(env, str, chars);
}

//----- (10001810) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_KillLoggingService(JNIEnv *env, jclass clz)
{
  int (*DPEC_KillLoggingService)(void); // eax

  DPEC_KillLoggingService = GetProcAddress(dpecHandle, aDpecKillloggin);
  return DPEC_KillLoggingService();
}

//----- (10001830) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_StartLoggingService(JNIEnv *env, jclass clz)
{
  int (*DPEC_StartLoggingService)(void); // eax

  DPEC_StartLoggingService = GetProcAddress(dpecHandle, aDpecStartloggi);
  return DPEC_StartLoggingService();
}

//----- (10001860) --------------------------------------------------------
int __stdcall Java_net_dvdplay_aem_DPEC_SetGlobalRef(
        JNIEnv *env,
        jclass clz,
        jstring lClassName,
        jstring lExceptionClassName,
        jstring lRegForAsynEventsName,
        jstring lCommonFunctionName,
        jstring lGetTaggedInfoName,
        jstring lGetStatusQuickName,
        jstring lRotateToSlotName,
        jstring lEjectCaseFromSlotName,
        jstring lVersionMajor,
        jstring lVersionMinor,
        jstring lVersionBuild,
        jstring lVersionString)
{
  const char *lExceptionClassNameChars; // edi
  const char *lRegForAsyncEventsNameChars; // ebx
  const char *lCommonFunctionNameChars; // ebp
  struct _jobject *dpecClass; // eax
  const char *lVersionMinorChars; // [esp+1B4h] [ebp-20h]
  const char *lVersionBuildChars; // [esp+1B8h] [ebp-1Ch]
  const char *lVersionStringChars; // [esp+1BCh] [ebp-18h]
  const char *lEjectCaseFromSlotNameChars; // [esp+1C0h] [ebp-14h]
  const char *lRotateToSlotNameChars; // [esp+1C4h] [ebp-10h]
  const char *lGetStatusQuickNameChars; // [esp+1C8h] [ebp-Ch]
  const char *lGetTaggedInfoNameChars; // [esp+1CCh] [ebp-8h]
  const char *lClassNameChars; // [esp+1D0h] [ebp-4h]
  const char *lVersionMajorChars; // [esp+1D8h] [ebp+4h]

  lClassNameChars = (*env)->GetStringUTFChars(env, lClassName, 0);
  lExceptionClassNameChars = (*env)->GetStringUTFChars(env, lExceptionClassName, 0);
  lRegForAsyncEventsNameChars = (*env)->GetStringUTFChars(env, lRegForAsynEventsName, 0);
  lCommonFunctionNameChars = (*env)->GetStringUTFChars(env, lCommonFunctionName, 0);
  lGetTaggedInfoNameChars = (*env)->GetStringUTFChars(env, lGetTaggedInfoName, 0);
  lGetStatusQuickNameChars = (*env)->GetStringUTFChars(env, lGetStatusQuickName, 0);
  lRotateToSlotNameChars = (*env)->GetStringUTFChars(env, lRotateToSlotName, 0);
  lEjectCaseFromSlotNameChars = (*env)->GetStringUTFChars(env, lEjectCaseFromSlotName, 0);
  lVersionMajorChars = (*env)->GetStringUTFChars(env, lVersionMajor, 0);
  lVersionMinorChars = (*env)->GetStringUTFChars(env, lVersionMinor, 0);
  lVersionBuildChars = (*env)->GetStringUTFChars(env, lVersionBuild, 0);
  lVersionStringChars = (*env)->GetStringUTFChars(env, lVersionString, 0);
  gExceptionClass = (int)(*env)->FindClass(env, lExceptionClassNameChars);
  if ( gExceptionClass )
  {
    dpecClass = (*env)->FindClass(env, lClassNameChars);
    gDpecClass = (int)dpecClass;
    if ( dpecClass )
    {
      gRegForAsyncEvents = (int)(*env)->GetStaticMethodID(env, dpecClass, lRegForAsyncEventsNameChars, aIiV);
      if ( gRegForAsyncEvents )
      {
        gCommonFunction = (int)(*env)->GetStaticMethodID(env, gDpecClass, lCommonFunctionNameChars, aIiiV);
        if ( gCommonFunction )
        {
          g_getTaggedInfo = (int)(*env)->GetStaticMethodID(env, gDpecClass, lGetTaggedInfoNameChars, aIiiljavaLangSt);
          if ( g_getTaggedInfo )
          {
            g_getStatusQuick = (int)(*env)->GetStaticMethodID(env, gDpecClass, lGetStatusQuickNameChars, aIiiiV);
            if ( g_getStatusQuick )
            {
              gRotateToSlot = (int)(*env)->GetStaticMethodID(env, gDpecClass, lRotateToSlotNameChars, aIiiiV);
              if ( gRotateToSlot )
              {
                gEjectCaseFromSlot = (int)(*env)->GetStaticMethodID(env, gDpecClass, lEjectCaseFromSlotNameChars, aIiiV);
                if ( gEjectCaseFromSlot )
                {
                  gVersionMajor = (int)(*env)->GetStaticFieldID(env, gDpecClass, lVersionMajorChars, aB);
                  if ( gVersionMajor )
                  {
                    gVersionMinor = (int)(*env)->GetStaticFieldID(env, gDpecClass, lVersionMinorChars, aB);
                    if ( gVersionMinor )
                    {
                      gVersionBuild = (int)(*env)->GetStaticFieldID(env, gDpecClass, lVersionBuildChars, aS);
                      if ( gVersionBuild )
                      {
                        gVersionString = (int)(*env)->GetStaticFieldID(
                                                env,
                                                gDpecClass,
                                                lVersionStringChars,
                                                aLjavaLangStrin);
                        if ( !gVersionString )
                          (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_9);
                      }
                      else
                      {
                        (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_8);
                      }
                    }
                    else
                    {
                      (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_7);
                    }
                  }
                  else
                  {
                    (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_6);
                  }
                }
                else
                {
                  (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_5);
                }
              }
              else
              {
                (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_4);
              }
            }
            else
            {
              (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_3);
            }
          }
          else
          {
            (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_2);
          }
        }
        else
        {
          (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_1);
        }
      }
      else
      {
        (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN_0);
      }
    }
    else
    {
      (*env)->ThrowNew(env, (jclass)gExceptionClass, aDpecBridgeCanN);
    }
  }
  (*env)->ReleaseStringUTFChars(env, lVersionMajor, lVersionMajorChars);
  (*env)->ReleaseStringUTFChars(env, lVersionMinor, lVersionMinorChars);
  (*env)->ReleaseStringUTFChars(env, lVersionBuild, lVersionBuildChars);
  (*env)->ReleaseStringUTFChars(env, lVersionString, lVersionStringChars);
  (*env)->ReleaseStringUTFChars(env, lEjectCaseFromSlotName, lEjectCaseFromSlotNameChars);
  (*env)->ReleaseStringUTFChars(env, lRotateToSlotName, lRotateToSlotNameChars);
  (*env)->ReleaseStringUTFChars(env, lGetStatusQuickName, lGetStatusQuickNameChars);
  (*env)->ReleaseStringUTFChars(env, lGetTaggedInfoName, lGetTaggedInfoNameChars);
  (*env)->ReleaseStringUTFChars(env, lCommonFunctionName, lCommonFunctionNameChars);
  (*env)->ReleaseStringUTFChars(env, lRegForAsynEventsName, lRegForAsyncEventsNameChars);
  (*env)->ReleaseStringUTFChars(env, lExceptionClassName, lExceptionClassNameChars);
  return ((int (__stdcall *)(JNIEnv *, jstring, const char *))(*env)->ReleaseStringUTFChars)(
           env,
           lClassName,
           lClassNameChars);
}
// 1000C198: using guessed type int dword_1000C198;
// 1000C1A4: using guessed type int dword_1000C1A4;
// 1000C1A8: using guessed type int dword_1000C1A8;
// 1000C1AC: using guessed type int dword_1000C1AC;
// 1000C1B0: using guessed type int dword_1000C1B0;
// 1000C1B4: using guessed type int dword_1000C1B4;
// 1000C1B8: using guessed type int dword_1000C1B8;
// 1000C1BC: using guessed type int dword_1000C1BC;
// 1000C200: using guessed type int dword_1000C200;
// 1000C204: using guessed type int dword_1000C204;
// 1000C208: using guessed type int dword_1000C208;
// 1000C20C: using guessed type int dword_1000C20C;

//----- (1000309F) --------------------------------------------------------
char __cdecl sub_1000309F(int a1)
{
  HMODULE ModuleHandleA; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  ModuleHandleA = GetModuleHandleA(0);
  if ( *(_WORD *)ModuleHandleA == 23117 )
  {
    v2 = *((_DWORD *)ModuleHandleA + 15);
    if ( v2 )
    {
      ModuleHandleA = (HMODULE)((char *)ModuleHandleA + v2);
      *(_BYTE *)a1 = *((_BYTE *)ModuleHandleA + 26);
      LOBYTE(ModuleHandleA) = *((_BYTE *)ModuleHandleA + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)ModuleHandleA;
    }
  }
  return (char)ModuleHandleA;
}

//----- (100030CC) --------------------------------------------------------
int sub_100030CC()
{
  int result; // eax
  CHAR *i; // ecx
  char v2; // al
  CHAR *v3; // eax
  CHAR *j; // ecx
  char v5; // al
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // ecx
  CHAR Buffer[4240]; // [esp+4h] [ebp-122Ch] BYREF
  CHAR Filename[260]; // [esp+1094h] [ebp-19Ch] BYREF
  _OSVERSIONINFOA VersionInformation; // [esp+1198h] [ebp-98h] BYREF
  _BYTE v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    return 1;
  }
  if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Buffer, 0x1090u) )
    goto LABEL_29;
  for ( i = Buffer; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", Buffer, 0x16u) )
  {
    v3 = Buffer;
  }
  else
  {
    GetModuleFileNameA(0, Filename, 0x104u);
    for ( j = Filename; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr(Buffer, Filename);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = v6 + 1;
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = strtol(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_1000309F((int)v12);
    return 3 - (v12[0] < 6u);
  }
  return result;
}

//----- (10003214) --------------------------------------------------------
int __cdecl sub_10003214(int a1)
{
  int v1; // eax
  int *v2; // eax

  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  v1 = sub_100030CC();
  dword_1000D7E8 = v1;
  if ( v1 == 3 )
  {
    v2 = (int *)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_10005430();
  }
  if ( !v2 )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}
// 10004BDF: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 1000D7E8: using guessed type int dword_1000D7E8;

//----- (10003271) --------------------------------------------------------
BOOL sub_10003271()
{
  int v0; // ebx
  LPVOID *v1; // esi
  _UNKNOWN **v2; // esi
  void *v3; // eax

  if ( dword_1000D7E8 == 3 )
  {
    v0 = 0;
    if ( dword_1000C588 > 0 )
    {
      v1 = (LPVOID *)((char *)lpMem + 12);
      do
      {
        VirtualFree(*v1, 0x100000u, 0x4000u);
        VirtualFree(*v1, 0, 0x8000u);
        HeapFree(hHeap, 0, v1[1]);
        v1 += 5;
        ++v0;
      }
      while ( v0 < dword_1000C588 );
    }
    HeapFree(hHeap, 0, lpMem);
  }
  else if ( dword_1000D7E8 == 2 )
  {
    v2 = &off_10009CB0;
    do
    {
      v3 = v2[4];
      if ( v3 )
        VirtualFree(v3, 0, 0x8000u);
      v2 = (_UNKNOWN **)*v2;
    }
    while ( v2 != &off_10009CB0 );
  }
  return HeapDestroy(hHeap);
}
// 10009CB0: using guessed type _UNKNOWN *off_10009CB0;
// 1000C588: using guessed type int dword_1000C588;
// 1000D7E8: using guessed type int dword_1000D7E8;

//----- (10003C70) --------------------------------------------------------
int __cdecl sub_10003C70(int a1, int a2)
{
  SIZE_T v2; // esi
  int result; // eax
  void *v4; // [esp+14h] [ebp-20h]
  size_t v5; // [esp+18h] [ebp-1Ch]

  v2 = a2 * a1;
  v5 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_1000D7E8 == 3 )
      {
        if ( v5 > dword_1000C590 )
          goto LABEL_14;
        _lock(9);
        v4 = (void *)__sbh_alloc_block(v5);
        _unlock(9);
        if ( v4 )
        {
          memset(v4, 0, v5);
          goto LABEL_14;
        }
LABEL_15:
        v4 = HeapAlloc(hHeap, 8u, v2);
        goto LABEL_16;
      }
      if ( dword_1000D7E8 == 2 && v2 <= dword_1000BCD4 )
      {
        _lock(9);
        v4 = (void *)sub_10005728(v2 >> 4);
        _unlock(9);
        if ( !v4 )
          goto LABEL_15;
        memset(v4, 0, v2);
      }
LABEL_14:
      if ( v4 )
        return (int)v4;
      goto LABEL_15;
    }
LABEL_16:
    if ( v4 || !dword_1000C41C )
      return (int)v4;
    result = _callnewh(v2);
    if ( !result )
      return result;
  }
}
// 10003BFA: using guessed type _DWORD __cdecl _lock(_DWORD);
// 10003C5B: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 10004F7B: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 1000BCD4: using guessed type int dword_1000BCD4;
// 1000C590: using guessed type int dword_1000C590;
// 1000D7E8: using guessed type int dword_1000D7E8;

//----- (10003DAD) --------------------------------------------------------
void __cdecl sub_10003DAD(LPVOID lpMem)
{
  _DWORD *block; // eax
  bool v2; // zf
  _BYTE *v3; // eax
  int v4; // [esp+Ch] [ebp-28h] BYREF
  _BYTE *v5; // [esp+10h] [ebp-24h]
  int v6; // [esp+14h] [ebp-20h] BYREF
  _DWORD *v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  if ( lpMem )
  {
    if ( dword_1000D7E8 == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      block = (_DWORD *)__sbh_find_block(lpMem);
      v7 = block;
      if ( block )
        sub_10004C52(block, (int)lpMem);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_1000D7E8 != 2 )
      {
LABEL_11:
        HeapFree(hHeap, 0, lpMem);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = (_BYTE *)sub_1000568C((unsigned int)lpMem, &v4, (unsigned int *)&v6);
      v5 = v3;
      if ( v3 )
        sub_100056E3(v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v5 == 0;
    }
    if ( !v2 )
      return;
    goto LABEL_11;
  }
}
// 10003BFA: using guessed type _DWORD __cdecl _lock(_DWORD);
// 10003C5B: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 10004C27: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 1000D7E8: using guessed type int dword_1000D7E8;

//----- (10003ED4) --------------------------------------------------------
LPVOID __cdecl sub_10003ED4(unsigned int a1)
{
  LPVOID result; // eax
  SIZE_T v2; // esi
  int v3; // eax
  SIZE_T v4; // eax
  void *v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-1Ch]

  if ( dword_1000D7E8 == 3 )
  {
    if ( a1 <= dword_1000C590 )
    {
      _lock(9);
      v5 = (void *)__sbh_alloc_block(a1);
      _unlock(9);
      result = v5;
      if ( v5 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_1000D7E8 != 2 )
  {
LABEL_12:
    v3 = a1;
    if ( !a1 )
      v3 = 1;
    v4 = v3 + 15;
    LOBYTE(v4) = v4 & 0xF0;
    return HeapAlloc(hHeap, 0, v4);
  }
  if ( a1 )
    v2 = (a1 + 15) & 0xFFFFFFF0;
  else
    v2 = 16;
  if ( v2 > dword_1000BCD4 )
    return HeapAlloc(hHeap, 0, v2);
  _lock(9);
  v6 = sub_10005728(v2 >> 4);
  _unlock(9);
  result = (LPVOID)v6;
  if ( !v6 )
    return HeapAlloc(hHeap, 0, v2);
  return result;
}
// 10003BFA: using guessed type _DWORD __cdecl _lock(_DWORD);
// 10003C5B: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 10004F7B: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 1000BCD4: using guessed type int dword_1000BCD4;
// 1000C590: using guessed type int dword_1000C590;
// 1000D7E8: using guessed type int dword_1000D7E8;

//----- (10004C52) --------------------------------------------------------
_DWORD *__cdecl sub_10004C52(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  bool v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  LPVOID *v18; // eax
  _DWORD *v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+18h] [ebp-4h]
  char *v23; // [esp+28h] [ebp+Ch]
  int *v24; // [esp+28h] [ebp+Ch]
  char v25; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v19 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v22 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v20 = *(int *)((char *)v3 + v5);
    v21 = *(_DWORD *)(a2 - 8);
    v23 = (char *)v3 + v5;
    if ( (v20 & 1) == 0 )
    {
      v7 = (v20 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v22;
        v6 = v23;
      }
      v5 += v20;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v22 = v5;
      *(_DWORD *)(*((_DWORD *)v23 + 1) + 8) = *((_DWORD *)v23 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v21 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v24 = (int *)((char *)v3 - v21);
      v14 = (v21 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v22 = v21 + v5;
      v13 = ((v21 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v24[1] == v24[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v24[2] + 4) = v24[1];
        *(_DWORD *)(v24[1] + 8) = v24[2];
      }
      v3 = v24;
    }
    if ( (v21 & 1) != 0 || v14 != v13 )
    {
      v17 = &v19[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v25 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v25 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v25 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v25 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v22;
    *(int *)((char *)v3 + v22 - 4) = v22;
    result += 129 * v4 + 81;
    v10 = (*v19)-- == 1;
    if ( v10 )
    {
      if ( dword_1000C584 )
      {
        VirtualFree((LPVOID)(*((_DWORD *)dword_1000C584 + 3) + (dword_1000C57C << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)dword_1000C584 + 2) |= 0x80000000 >> dword_1000C57C;
        *(_DWORD *)(*((_DWORD *)dword_1000C584 + 4) + 4 * dword_1000C57C + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_1000C584 + 4) + 67);
        v18 = (LPVOID *)dword_1000C584;
        if ( !*(_BYTE *)(*((_DWORD *)dword_1000C584 + 4) + 67) )
        {
          *((_DWORD *)dword_1000C584 + 1) &= ~1u;
          v18 = (LPVOID *)dword_1000C584;
        }
        if ( v18[2] == (LPVOID)-1 )
        {
          VirtualFree(v18[3], 0, 0x8000u);
          HeapFree(hHeap, 0, *((LPVOID *)dword_1000C584 + 4));
          memcpy_0(
            dword_1000C584,
            (char *)dword_1000C584 + 20,
            (size_t)lpMem + 20 * dword_1000C588 - (_DWORD)dword_1000C584 - 20);
          --dword_1000C588;
          if ( a1 > dword_1000C584 )
            a1 -= 5;
          dword_1000C580 = (int)lpMem;
        }
      }
      result = a1;
      dword_1000C57C = v4;
      dword_1000C584 = a1;
    }
  }
  return result;
}
// 1000C57C: using guessed type int dword_1000C57C;
// 1000C580: using guessed type int dword_1000C580;
// 1000C588: using guessed type int dword_1000C588;

//----- (10005430) --------------------------------------------------------
int *sub_10005430()
{
  int *v0; // esi
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int *v3; // eax
  int v4; // ebp
  int v5; // edx

  if ( dword_10009CC0 == -1 )
  {
    v0 = (int *)&off_10009CB0;
  }
  else
  {
    v0 = (int *)HeapAlloc(hHeap, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != (int *)&off_10009CB0 )
      HeapFree(hHeap, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree(v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == (int *)&off_10009CB0 )
  {
    if ( !off_10009CB0 )
      off_10009CB0 = &off_10009CB0;
    if ( !off_10009CB4 )
      off_10009CB4 = &off_10009CB0;
  }
  else
  {
    *v0 = (int)&off_10009CB0;
    v0[1] = (int)off_10009CB4;
    off_10009CB4 = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = (int)(v2 + 0x100000);
  v3 = v0 + 6;
  v0[3] = (int)(v0 + 38);
  v0[4] = (int)v2;
  v0[2] = (int)(v0 + 6);
  v4 = 0;
  do
  {
    v5 = v4++ >= 16 ? -1 : 240;
    *v3 = v5;
    v3[1] = 241;
    v3 += 2;
  }
  while ( v4 < 1024 );
  memset(v2, 0, 0x10000u);
  while ( (unsigned int)v2 < v0[4] + 0x10000 )
  {
    *((_BYTE *)v2 + 248) = -1;
    *v2 = v2 + 2;
    v2[1] = 240;
    v2 += 1024;
  }
  return v0;
}
// 10009CB0: using guessed type _UNKNOWN *off_10009CB0;
// 10009CC0: using guessed type int dword_10009CC0;

//----- (10005574) --------------------------------------------------------
_UNKNOWN **__cdecl sub_10005574(LPVOID *lpMem)
{
  _UNKNOWN **result; // eax

  result = (_UNKNOWN **)VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_1000BCD0 == (_UNKNOWN **)lpMem )
  {
    result = (_UNKNOWN **)lpMem[1];
    off_1000BCD0 = result;
  }
  if ( lpMem == (LPVOID *)&off_10009CB0 )
  {
    dword_10009CC0 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    return (_UNKNOWN **)HeapFree(hHeap, 0, lpMem);
  }
  return result;
}
// 10009CB0: using guessed type _UNKNOWN *off_10009CB0;
// 10009CC0: using guessed type int dword_10009CC0;
// 1000BCD0: using guessed type _UNKNOWN **off_1000BCD0;

//----- (100055CA) --------------------------------------------------------
void __cdecl sub_100055CA(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = off_10009CB4;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && VirtualFree((LPVOID)(v1[4] + i), 0x1000u, 0x4000u) )
        {
          *v2 = -1;
          --dword_1000C3DC;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_10005574((LPVOID *)v5);
      }
    }
  }
  while ( v1 != off_10009CB4 && a1 > 0 );
}
// 1000C3DC: using guessed type int dword_1000C3DC;

//----- (1000568C) --------------------------------------------------------
unsigned int __cdecl sub_1000568C(unsigned int a1, _DWORD *a2, unsigned int *a3)
{
  _UNKNOWN **v3; // ecx

  v3 = &off_10009CB0;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (_UNKNOWN **)*v3;
    if ( v3 == &off_10009CB0 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 10009CB0: using guessed type _UNKNOWN *off_10009CB0;

//----- (100056E3) --------------------------------------------------------
void __cdecl sub_100056E3(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_1000C3DC == 32 )
    sub_100055CA(16);
}
// 1000C3DC: using guessed type int dword_1000C3DC;

//----- (10005728) --------------------------------------------------------
int __cdecl sub_10005728(unsigned int a1)
{
  _UNKNOWN **v1; // esi
  void *v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  int result; // eax
  char *v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *i; // esi
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  _UNKNOWN **v13; // eax
  bool v14; // cf
  int *v15; // eax
  int v16; // ecx
  unsigned int Val; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = off_1000BCD0;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = (int)v2 + 4096 * (((char *)v3 - (char *)v1 - 24) >> 3);
      v18 = v4;
      if ( v3 < (unsigned int *)v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = sub_10005930(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              off_1000BCD0 = v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int *)v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (unsigned int *)(v1 + 6);
      Val = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < Val )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = sub_10005930(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < Val );
      }
    }
    v1 = (_UNKNOWN **)*v1;
  }
  while ( v1 != off_1000BCD0 );
  v7 = (char *)&off_10009CB0;
  while ( *((_DWORD *)v7 + 4) == -1 || !*((_DWORD *)v7 + 3) )
  {
    v7 = *(char **)v7;
    if ( v7 == (char *)&off_10009CB0 )
    {
      v15 = sub_10005430();
      if ( v15 )
      {
        v16 = v15[4];
        *(_BYTE *)(v16 + 8) = v5;
        off_1000BCD0 = (_UNKNOWN **)v15;
        *(_DWORD *)v16 = v16 + v5 + 8;
        *(_DWORD *)(v16 + 4) = 240 - v5;
        v15[6] -= (unsigned __int8)v5;
        return v16 + 256;
      }
      return 0;
    }
  }
  v8 = (_DWORD *)*((_DWORD *)v7 + 3);
  v20 = 0;
  v9 = v8;
  for ( i = (_DWORD *)(*((_DWORD *)v7 + 4) + (((char *)v8 - v7 - 24) >> 3 << 12)); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( VirtualAlloc(i, v20 << 12, 0x1000u, 4u) != i )
    return 0;
  v11 = v8;
  if ( v20 > 0 )
  {
    v12 = i + 1;
    do
    {
      *((_BYTE *)v12 + 244) = -1;
      *(v12 - 1) = v12 + 1;
      *v12 = 240;
      *v11 = 240;
      v11[1] = 241;
      v12 += 1024;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_1000BCD0 = (_UNKNOWN **)v7;
  v13 = (_UNKNOWN **)(v7 + 8216);
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == -1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  *((_DWORD *)v7 + 3) = v14 ? v11 : 0;
  *((_BYTE *)i + 8) = a1;
  *((_DWORD *)v7 + 2) = v8;
  *v8 -= a1;
  i[1] -= a1;
  result = (int)(i + 64);
  *i = (char *)i + a1 + 8;
  return result;
}
// 10009CB0: using guessed type _UNKNOWN *off_10009CB0;
// 1000BCD0: using guessed type _UNKNOWN **off_1000BCD0;

//----- (10005930) --------------------------------------------------------
int __cdecl sub_10005930(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (10005EB0) --------------------------------------------------------
int sub_10005EB0()
{
  return flsall(1);
}
// 10005EB9: using guessed type _DWORD __cdecl flsall(_DWORD);

// nfuncs=160 queued=38 decompiled=38 lumina nreq=0 worse=0 better=0
// ALL OK, 38 function(s) have been successfully decompiled
